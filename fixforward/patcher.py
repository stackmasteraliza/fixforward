"""Safe patch application with branch management."""

import subprocess
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import List

from fixforward.copilot import PatchResult
from fixforward.state import save_state, RollbackState


class PatchError(Exception):
    pass


@dataclass
class BranchInfo:
    name: str
    original_branch: str
    files_changed: List[str]


def _git(args, cwd):
    """Run a git command."""
    result = subprocess.run(
        ["git"] + args,
        capture_output=True,
        text=True,
        cwd=str(cwd),
    )
    return result


def _ensure_git_repo(path: Path):
    """Ensure the path is a git repo with at least one commit."""
    # Check if inside a git work tree
    result = _git(["rev-parse", "--is-inside-work-tree"], cwd=path)
    if result.returncode != 0:
        # Not in any git repo — initialize one here
        init = _git(["init"], cwd=path)
        if init.returncode != 0:
            raise PatchError(f"Could not initialize git in {path}")

    # Check if there's at least one commit
    result = _git(["rev-parse", "HEAD"], cwd=path)
    if result.returncode != 0:
        # No commits yet — create initial commit
        _git(["add", "-A"], cwd=path)
        _git(["commit", "-m", "initial state (auto-created by fixforward)",
              "--allow-empty"], cwd=path)


def apply_patch(patch: PatchResult, project_path: str) -> BranchInfo:
    """Apply patch on a safe temporary branch."""
    path = Path(project_path).resolve()

    _ensure_git_repo(path)

    # Get the git toplevel to understand our context
    toplevel_result = _git(["rev-parse", "--show-toplevel"], cwd=path)
    git_root = Path(toplevel_result.stdout.strip()) if toplevel_result.returncode == 0 else path

    # Get current branch
    result = _git(["rev-parse", "--abbrev-ref", "HEAD"], cwd=path)
    if result.returncode != 0:
        raise PatchError("Could not determine current branch.")
    original_branch = result.stdout.strip()

    # Check for dirty state and stash if needed
    status = _git(["status", "--porcelain"], cwd=path)
    stash_ref = None
    if status.stdout.strip():
        stash_result = _git(["stash", "push", "-m", "fixforward-auto-stash"], cwd=path)
        if stash_result.returncode == 0:
            stash_ref = "fixforward-auto-stash"

    # Create the fixforward branch
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    branch_name = f"fixforward/auto-{timestamp}"

    result = _git(["checkout", "-b", branch_name], cwd=path)
    if result.returncode != 0:
        if stash_ref:
            _git(["stash", "pop"], cwd=path)
        raise PatchError(f"Could not create branch {branch_name}: {result.stderr}")

    # Apply file changes
    files_changed = []
    for change in patch.changes:
        file_path = path / change.file_path
        try:
            file_path.parent.mkdir(parents=True, exist_ok=True)
            if change.modified_content:
                file_path.write_text(change.modified_content)
                files_changed.append(change.file_path)
        except Exception as e:
            _git(["checkout", original_branch], cwd=path)
            _git(["branch", "-D", branch_name], cwd=path)
            if stash_ref:
                _git(["stash", "pop"], cwd=path)
            raise PatchError(f"Failed to write {change.file_path}: {e}")

    # Stage all changes
    if files_changed:
        _git(["add"] + files_changed, cwd=path)

    # Commit
    commit_msg = (
        f"fix: auto-resolve test failures\n\n"
        f"Generated by FixForward powered by GitHub Copilot CLI.\n"
        f"Files changed: {', '.join(files_changed)}"
    )
    _git(["commit", "-m", commit_msg], cwd=path)

    # Save rollback state
    save_state(RollbackState(
        project_path=str(path),
        original_branch=original_branch,
        fixforward_branch=branch_name,
        stash_ref=stash_ref,
        timestamp=timestamp,
        files_changed=files_changed,
    ))

    return BranchInfo(
        name=branch_name,
        original_branch=original_branch,
        files_changed=files_changed,
    )
